/**
 * ForkMonkey - Professional Web Interface
 * Version 2.0 - Complete Redesign
 * 
 * All data is loaded from static JSON files generated by GitHub Actions.
 * No backend required - pure static site for GitHub Pages.
 */

const ForkMonkey = {
    // Application state
    data: {
        dna: null,
        stats: null,
        history: null,
        community: null,
        leaderboard: null,
        familyTree: null,
        networkStats: null
    },

    currentTab: 'dashboard',
    treeZoom: 1,

    // Adoption wizard state
    adoption: {
        method: null,       // 'manual', 'trustless', 'oauth'
        step: 1,
        customization: {}
    },

    // Configuration
    config: {
        repoOwner: 'roeiba',
        repoName: 'forkMonkey',
        refreshInterval: 60000, // 60 seconds
        // apiBaseUrl: '/api',      // Production URL
        // apiBaseUrl: 'http://localhost:8080/api' // For local development
        apiBaseUrl: 'https://forkmonkey-backend-1068119864554.us-central1.run.app/api' // Production Backend (Cloud Run)
    },

    // Loading messages for fun UX
    loadingMessages: [
        "üêµ Waking up your monkey...",
        "üß¨ Decoding DNA sequence...",
        "üçå Feeding the monkey...",
        "‚ú® Checking for mutations...",
        "üåô Consulting the AI oracle...",
        "üîÆ Reading monkey fortune...",
        "üé® Rendering pixels...",
        "üß™ Analyzing genetics..."
    ],

    /**
     * Initialize the application
     */
    async init() {
        console.log('%cüêµ ForkMonkey v2.0 Initializing...', 'color: #00ff88; font-size: 16px; font-weight: bold;');

        // Start fun loading messages
        this.startLoadingMessages();

        // Initialize particles background
        this.initParticles();

        // Set up tab navigation
        this.initTabs();

        // Load all data
        await this.loadAllData();

        // Render initial view
        this.renderDashboard();

        // Set up auto-refresh
        this.startAutoRefresh();

        // Keyboard shortcuts
        this.initKeyboardShortcuts();

        // Initialize floating CTA visibility
        this.initFloatingCTA();

        // Track page view
        this.trackEvent('page_view', { page: 'dashboard' });

        console.log('%c‚úÖ ForkMonkey Ready!', 'color: #00ff88; font-size: 14px;');
        this.showToast('üêµ ForkMonkey loaded!', 'success');
    },

    /**
     * Rotate fun loading messages
     */
    startLoadingMessages() {
        const messageEl = document.querySelector('.loading-message');
        if (!messageEl) return;

        let index = 0;
        this.loadingInterval = setInterval(() => {
            index = (index + 1) % this.loadingMessages.length;
            messageEl.textContent = this.loadingMessages[index];
        }, 1500);
    },

    /**
     * Stop loading messages
     */
    stopLoadingMessages() {
        if (this.loadingInterval) {
            clearInterval(this.loadingInterval);
        }
    },

    /**
     * Initialize floating CTA visibility on scroll
     */
    initFloatingCTA() {
        const floatingCta = document.getElementById('floating-cta');
        if (!floatingCta) return;

        // Show after scrolling down
        let lastScroll = 0;
        window.addEventListener('scroll', () => {
            const currentScroll = window.scrollY;
            if (currentScroll > 300) {
                floatingCta.classList.add('visible');
            } else {
                floatingCta.classList.remove('visible');
            }
            lastScroll = currentScroll;
        });

        // Track click
        floatingCta.addEventListener('click', () => {
            this.trackEvent('cta_click', { location: 'floating_mobile' });
        });
    },

    /**
     * Get base path for data files
     */
    getBasePath() {
        const isGitHubPages = window.location.hostname.includes('github.io');
        return isGitHubPages ? '' : '/';
    },

    /**
     * Load all static JSON data files
     */
    async loadAllData() {
        const basePath = this.getBasePath();

        const files = [
            ['dna', `${basePath}monkey_data/dna.json`],
            ['stats', `${basePath}monkey_data/stats.json`],
            ['history', `${basePath}monkey_data/history.json`],
            ['community', `${basePath}community_data.json`],
            ['leaderboard', `${basePath}leaderboard.json`],
            ['familyTree', `${basePath}family_tree.json`],
            ['networkStats', `${basePath}network_stats.json`]
        ];

        const results = await Promise.allSettled(
            files.map(async ([key, url]) => {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${key}`);
                return { key, data: await response.json() };
            })
        );

        results.forEach(result => {
            if (result.status === 'fulfilled') {
                this.data[result.value.key] = result.value.data;
            }
        });

        // Update nav stats
        this.updateNavStats();
    },

    /**
     * Update navigation bar stats
     */
    updateNavStats() {
        const stats = this.data.stats;
        if (stats) {
            document.getElementById('nav-rarity').textContent = `${(stats.rarity_score || 0).toFixed(1)}%`;
        }
        // Fetch GitHub stats for social proof
        this.fetchGitHubStats();
    },

    /**
     * Fetch GitHub repository stats for social proof
     */
    async fetchGitHubStats() {
        try {
            const response = await fetch(`https://api.github.com/repos/${this.config.repoOwner}/${this.config.repoName}`);
            if (response.ok) {
                const data = await response.json();
                // Update nav stats
                const starsEl = document.getElementById('nav-stars');
                const forksEl = document.getElementById('nav-forks');
                if (starsEl) starsEl.textContent = this.formatNumber(data.stargazers_count);
                if (forksEl) forksEl.textContent = this.formatNumber(data.forks_count);
                
                // Update social proof bar
                const proofStars = document.getElementById('proof-stars');
                const proofForks = document.getElementById('proof-forks');
                if (proofStars) proofStars.textContent = `‚≠ê ${this.formatNumber(data.stargazers_count)} stars`;
                if (proofForks) proofForks.textContent = `üç¥ ${this.formatNumber(data.forks_count)} monkeys`;
                
                // Store for later use
                this.githubStats = data;
            }
        } catch (error) {
            console.log('Could not fetch GitHub stats:', error);
        }
    },

    /**
     * Format number with K/M suffix
     */
    formatNumber(num) {
        if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
        return num.toString();
    },

    /**
     * Track analytics event
     */
    trackEvent(event, params = {}) {
        // Google Analytics
        if (typeof gtag !== 'undefined') {
            gtag('event', event, params);
        }
        // Console for debugging
        console.log(`[ForkMonkey Track] ${event}`, params);
    },

    /**
     * Initialize tab navigation
     */
    initTabs() {
        const tabs = document.querySelectorAll('.nav-tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.dataset.tab;
                this.switchTab(tabId);
            });
        });
    },

    /**
     * Switch to a specific tab
     */
    switchTab(tabId) {
        // Update tab buttons
        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.nav-tab[data-tab="${tabId}"]`)?.classList.add('active');

        // Update content sections
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(tabId)?.classList.add('active');

        this.currentTab = tabId;

        // Track tab view
        this.trackEvent('tab_view', { tab: tabId });

        // Render content for the tab
        switch (tabId) {
            case 'dashboard':
                this.renderDashboard();
                break;
            case 'evolution':
                this.renderEvolution();
                break;
            case 'community':
                this.renderCommunity();
                break;
            case 'leaderboard':
                this.renderLeaderboard();
                break;
            case 'family-tree':
                this.renderFamilyTree();
                break;
        }
    },

    /**
     * Render Dashboard
     */
    renderDashboard() {
        const dna = this.data.dna;
        const stats = this.data.stats;
        const networkStats = this.data.networkStats;

        // Load monkey SVG
        this.loadMonkeySVG();

        // Update DNA hash
        if (dna) {
            document.getElementById('dna-hash').textContent = dna.dna_hash || 'Unknown';
        }

        // Update stats
        if (stats) {
            document.getElementById('stat-generation').textContent = stats.generation || 1;
            document.getElementById('stat-age').textContent = `${stats.age_days || 0} days`;
            document.getElementById('stat-rarity').textContent = `${(stats.rarity_score || 0).toFixed(1)}%`;
            document.getElementById('stat-mutations').textContent = stats.mutation_count || 0;
            document.getElementById('stat-parent').textContent = stats.parent_id || 'Genesis';

            // Render traits
            this.renderTraits(stats.traits);
        }

        // Update network stats
        if (networkStats) {
            document.getElementById('network-total').textContent = networkStats.total_monkeys || 0;
            document.getElementById('network-active').textContent = networkStats.active_today || 0;
            document.getElementById('network-avg-rarity').textContent = `${(networkStats.avg_rarity || 0).toFixed(1)}%`;

            if (networkStats.last_updated) {
                const date = new Date(networkStats.last_updated);
                document.getElementById('network-updated').textContent = `Last scan: ${date.toLocaleDateString()}`;
            }
        }
    },

    /**
     * Load and display monkey SVG
     */
    async loadMonkeySVG() {
        const frame = document.getElementById('monkey-frame');
        const basePath = this.getBasePath();

        // Stop loading messages
        this.stopLoadingMessages();

        try {
            const response = await fetch(`${basePath}monkey_data/monkey.svg`);
            if (response.ok) {
                const svgText = await response.text();
                frame.innerHTML = svgText;
            } else {
                throw new Error('SVG not found');
            }
        } catch (error) {
            frame.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üêµ</div>
                    <div class="empty-state-title">No Monkey Yet</div>
                    <div class="empty-state-text">Fork the repo to create your own monkey!</div>
                    <a href="https://github.com/roeiba/forkMonkey/fork" target="_blank" class="cta-button primary" style="margin-top: 16px; display: inline-flex;">
                        üß¨ Fork Your Monkey Now
                    </a>
                </div>
            `;
        }
    },

    /**
     * Render traits list
     */
    renderTraits(traits) {
        const container = document.getElementById('traits-list');
        if (!traits) {
            container.innerHTML = '<div class="empty-state small">No traits data</div>';
            return;
        }

        const sortedTraits = Object.entries(traits).sort((a, b) => a[0].localeCompare(b[0]));

        container.innerHTML = sortedTraits.map(([name, trait]) => {
            const rarity = typeof trait === 'object' ? trait.rarity : 'common';
            const value = typeof trait === 'object' ? trait.value : trait;

            return `
                <div class="trait-item ${rarity}">
                    <span class="trait-name">${this.formatName(name)}</span>
                    <span class="trait-value">${this.formatName(value)}</span>
                    <span class="trait-rarity ${rarity}">${rarity}</span>
                </div>
            `;
        }).join('');
    },

    /**
     * Render Evolution Timeline
     */
    async renderEvolution() {
        const timeline = document.getElementById('evolution-timeline');
        const history = this.data.history;

        if (!history || !history.entries || history.entries.length === 0) {
            timeline.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üìú</div>
                    <div class="empty-state-title">No Evolution History</div>
                    <div class="empty-state-text">Your monkey will start evolving daily!</div>
                </div>
            `;
            document.getElementById('evolution-count').textContent = '0';
            return;
        }

        const entries = history.entries.slice().reverse(); // Most recent first
        document.getElementById('evolution-count').textContent = entries.length;

        // Show loading state
        timeline.innerHTML = `
            <div class="loading-state">
                <div class="loader"></div>
                <p>Loading evolution snapshots...</p>
            </div>
        `;

        // Load SVGs for each entry (use svg_filename if available, otherwise fallback to timestamp)
        const entriesWithSvgs = await Promise.all(entries.map(async (entry, index) => {
            const svgContent = await this.getEvolutionSvg(entry.timestamp, entry.svg_filename);
            return { ...entry, svgContent, originalIndex: index };
        }));

        timeline.innerHTML = entriesWithSvgs.map((entry, index) => {
            const date = new Date(entry.timestamp);
            const dateStr = date.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined,
                hour: '2-digit',
                minute: '2-digit'
            });

            // Truncate story for display
            const story = entry.story || 'Evolution occurred';
            const shortStory = story.length > 100 ? story.substring(0, 97) + '...' : story;

            // Use SVG if available, otherwise show emoji
            const previewContent = entry.svgContent
                ? entry.svgContent
                : '<div style="font-size: 2.5rem;">üêµ</div>';

            return `
                <div class="evolution-card" onclick="ForkMonkey.showEvolutionDetail(${index})" style="animation-delay: ${index * 0.02}s">
                    <div class="evolution-card-preview">
                        ${previewContent}
                    </div>
                    <div class="evolution-card-info">
                        <div class="evolution-date">${dateStr}</div>
                        <div class="evolution-stats">
                            <span class="evolution-gen">Gen ${entry.generation}</span>
                            <span class="evolution-rarity">Rarity: ${(entry.rarity_score || 0).toFixed(1)}%</span>
                            <span style="color: var(--accent);">Mutations: ${entry.mutation_count || 0}</span>
                        </div>
                        <div class="evolution-story">${shortStory}</div>
                    </div>
                </div>
            `;
        }).join('');
    },

    /**
     * Get evolution SVG for a specific history entry
     * Uses svg_filename if available (new entries), otherwise calculates from timestamp (legacy)
     * 
     * @param {string} timestamp - ISO timestamp of the entry
     * @param {string|null} svgFilename - Direct SVG filename if available
     */
    async getEvolutionSvg(timestamp, svgFilename = null) {
        const basePath = this.getBasePath();

        // Check cache first
        if (!this.svgCache) this.svgCache = {};

        // If we have a direct filename, use it
        let filename = svgFilename;

        // Otherwise, calculate from timestamp (legacy entries)
        if (!filename) {
            const date = new Date(timestamp);
            // Format: YYYY-MM-DD_HH-mm_monkey.svg (using UTC to match GitHub Actions)
            const year = date.getUTCFullYear();
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            filename = `${year}-${month}-${day}_${hours}-${minutes}_monkey.svg`;
        }

        // Check cache
        if (this.svgCache[filename]) {
            return this.svgCache[filename];
        }

        const svgPath = `${basePath}monkey_evolution/${filename}`;

        try {
            const response = await fetch(svgPath);
            if (response.ok) {
                const svgContent = await response.text();
                this.svgCache[filename] = svgContent;
                return svgContent;
            }
        } catch (error) {
            // SVG not available for this entry
        }

        return null;
    },

    /**
     * Show evolution entry detail in modal
     */
    async showEvolutionDetail(index) {
        const entries = this.data.history.entries.slice().reverse();
        const entry = entries[index];
        if (!entry) return;

        // Get actual SVG for this entry (use svg_filename if available)
        const svgContent = await this.getEvolutionSvg(entry.timestamp, entry.svg_filename);
        const svgDisplay = svgContent
            ? svgContent
            : '<div style="font-size: 4rem;">üêµ</div>';

        const date = new Date(entry.timestamp);
        const dateStr = date.toLocaleDateString('en-US', {
            weekday: 'long',
            month: 'long',
            day: 'numeric',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });

        const traitsHtml = Object.entries(entry.traits || {}).map(([key, value]) => `
            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                <span style="color: var(--text-muted); text-transform: capitalize;">${this.formatName(key)}</span>
                <span style="color: var(--primary); text-transform: capitalize;">${value}</span>
            </div>
        `).join('');

        const content = `
            <div class="evolution-detail-modal">
                <!-- Date Header -->
                <div style="text-align: center; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border-subtle);">
                    <h3 style="color: var(--primary); font-family: var(--font-display); font-size: 0.85rem; letter-spacing: 1px;">${dateStr}</h3>
                </div>
                
                <!-- Monkey Image Container -->
                <div style="display: flex; justify-content: center; align-items: center; margin-bottom: 24px; background: radial-gradient(circle, rgba(0, 255, 136, 0.05) 0%, transparent 70%); border-radius: 16px; padding: 20px;">
                    <div class="evolution-modal-image-container">
                        ${svgDisplay}
                    </div>
                </div>
                
                <!-- Story Section -->
                <div style="margin-bottom: 24px; background: var(--bg-card); padding: 16px; border-radius: 12px; border-left: 3px solid var(--primary);">
                    <h4 style="color: var(--primary); margin-bottom: 12px; font-size: 0.9rem;">üìñ Story</h4>
                    <p style="color: var(--text-secondary); line-height: 1.6; font-size: 0.9rem;">${entry.story || 'Evolution occurred'}</p>
                </div>
                
                <!-- Stats Grid -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 24px;">
                    <div style="text-align: center; padding: 16px; background: var(--bg-card); border-radius: 12px; border: 1px solid var(--border-subtle);">
                        <div style="color: var(--text-muted); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">Generation</div>
                        <div style="color: var(--primary); font-size: 1.5rem; font-weight: bold; margin-top: 4px;">${entry.generation}</div>
                    </div>
                    <div style="text-align: center; padding: 16px; background: var(--bg-card); border-radius: 12px; border: 1px solid var(--border-subtle);">
                        <div style="color: var(--text-muted); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">Rarity</div>
                        <div style="color: var(--gold); font-size: 1.5rem; font-weight: bold; margin-top: 4px;">${(entry.rarity_score || 0).toFixed(1)}%</div>
                    </div>
                    <div style="text-align: center; padding: 16px; background: var(--bg-card); border-radius: 12px; border: 1px solid var(--border-subtle);">
                        <div style="color: var(--text-muted); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">Mutations</div>
                        <div style="color: var(--accent); font-size: 1.5rem; font-weight: bold; margin-top: 4px;">${entry.mutation_count || 0}</div>
                    </div>
                    <div style="text-align: center; padding: 16px; background: var(--bg-card); border-radius: 12px; border: 1px solid var(--border-subtle);">
                        <div style="color: var(--text-muted); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">DNA Hash</div>
                        <div style="color: var(--text-secondary); font-size: 0.7rem; font-family: var(--font-mono); margin-top: 8px; word-break: break-all;">${entry.dna_hash || 'N/A'}</div>
                    </div>
                </div>
                
                <!-- Traits Section -->
                <div style="background: var(--bg-card); padding: 16px; border-radius: 12px;">
                    <h4 style="color: var(--primary); margin-bottom: 12px; font-size: 0.9rem;">‚ú® Traits</h4>
                    ${traitsHtml}
                </div>
            </div>
        `;

        this.openModal(content);
    },

    /**
     * Render Community Gallery
     */
    renderCommunity() {
        const grid = document.getElementById('community-grid');
        const community = this.data.community;

        if (!community || !community.forks || community.forks.length === 0) {
            grid.innerHTML = `
                <div class="empty-state" style="grid-column: 1 / -1;">
                    <div class="empty-state-icon">üåç</div>
                    <div class="empty-state-title">No Community Data</div>
                    <div class="empty-state-text">The community scanner runs daily. Check back soon!</div>
                </div>
            `;
            document.getElementById('community-total').textContent = '0';
            return;
        }

        document.getElementById('community-total').textContent = community.forks.length;

        this.renderCommunityGrid(community.forks);
    },

    /**
     * Render community grid with forks
     */
    renderCommunityGrid(forks) {
        const grid = document.getElementById('community-grid');

        grid.innerHTML = forks.map(fork => {
            const stats = fork.monkey_stats || {};
            const svgContent = fork.monkey_svg
                ? fork.monkey_svg
                : '<div style="font-size: 3rem;">üêµ</div>';

            return `
                <a href="${fork.url}" target="_blank" class="community-card ${fork.is_root ? 'root' : ''}">
                    ${fork.is_root ? '<div class="card-badge">ROOT</div>' : ''}
                    <div class="card-preview">
                        ${svgContent}
                    </div>
                    <div class="card-info">
                        <div class="card-owner">${fork.owner}/${fork.repo}</div>
                        <div class="card-stats">
                            <div class="card-stat">
                                <span class="card-stat-value">${stats.generation || '?'}</span>
                                <span>Gen</span>
                            </div>
                            <div class="card-stat">
                                <span class="card-stat-value">${(stats.rarity_score || 0).toFixed(1)}%</span>
                                <span>Rarity</span>
                            </div>
                            <div class="card-stat">
                                <span class="card-stat-value">${stats.age_days || 0}d</span>
                                <span>Age</span>
                            </div>
                        </div>
                    </div>
                </a>
            `;
        }).join('');
    },

    /**
     * Sort community grid
     */
    sortCommunity() {
        const sortBy = document.getElementById('community-sort').value;
        const community = this.data.community;

        if (!community || !community.forks) return;

        let sorted = [...community.forks];

        switch (sortBy) {
            case 'rarity':
                sorted.sort((a, b) => (b.monkey_stats?.rarity_score || 0) - (a.monkey_stats?.rarity_score || 0));
                break;
            case 'rarity-asc':
                sorted.sort((a, b) => (a.monkey_stats?.rarity_score || 0) - (b.monkey_stats?.rarity_score || 0));
                break;
            case 'age':
                sorted.sort((a, b) => (b.monkey_stats?.age_days || 0) - (a.monkey_stats?.age_days || 0));
                break;
            case 'recent':
                sorted.sort((a, b) => new Date(b.updated_at || 0) - new Date(a.updated_at || 0));
                break;
            case 'generation':
                sorted.sort((a, b) => (a.monkey_stats?.generation || 1) - (b.monkey_stats?.generation || 1));
                break;
        }

        this.renderCommunityGrid(sorted);
    },

    /**
     * Render Leaderboard
     */
    renderLeaderboard() {
        const tbody = document.getElementById('leaderboard-body');
        const leaderboard = this.data.leaderboard;

        if (!leaderboard || !leaderboard.rankings || leaderboard.rankings.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="6" class="loading-cell">
                        <div class="empty-state" style="padding: 32px;">
                            <div class="empty-state-icon">üèÜ</div>
                            <div class="empty-state-title">No Rankings Yet</div>
                            <div class="empty-state-text">The leaderboard updates daily.</div>
                        </div>
                    </td>
                </tr>
            `;
            return;
        }

        tbody.innerHTML = leaderboard.rankings.map(entry => {
            const rankDisplay = this.getRankDisplay(entry.rank);
            const svgContent = entry.monkey_svg
                ? entry.monkey_svg
                : '<div style="font-size: 1.5rem;">üêµ</div>';

            return `
                <tr class="${entry.rank <= 3 ? 'top-3' : ''}">
                    <td class="rank-col">
                        ${rankDisplay}
                    </td>
                    <td class="monkey-col">
                        <div class="monkey-preview">${svgContent}</div>
                    </td>
                    <td class="owner-col">
                        <a href="${entry.url}" target="_blank" class="owner-link">
                            ${entry.owner}/${entry.repo}
                        </a>
                    </td>
                    <td class="rarity-col">
                        <span class="rarity-display">${(entry.rarity_score || 0).toFixed(1)}%</span>
                    </td>
                    <td class="gen-col">${entry.generation || 1}</td>
                    <td class="age-col">${entry.age_days || 0} days</td>
                </tr>
            `;
        }).join('');
    },

    /**
     * Get rank display with medal
     */
    getRankDisplay(rank) {
        if (rank === 1) return '<span class="rank-medal">ü•á</span>';
        if (rank === 2) return '<span class="rank-medal">ü•à</span>';
        if (rank === 3) return '<span class="rank-medal">ü•â</span>';
        return `<span class="rank-display">#${rank}</span>`;
    },

    /**
     * Render Family Tree
     */
    renderFamilyTree() {
        const canvas = document.getElementById('family-tree-canvas');
        const tree = this.data.familyTree;

        if (!tree || !tree.nodes || tree.nodes.length === 0) {
            canvas.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üå≥</div>
                    <div class="empty-state-title">No Family Tree Data</div>
                    <div class="empty-state-text">Fork genealogy updates daily.</div>
                </div>
            `;
            return;
        }

        // Simple hierarchical layout
        const rootNode = tree.nodes.find(n => n.is_root);
        const childNodes = tree.nodes.filter(n => !n.is_root);

        let html = '<div style="display: flex; flex-direction: column; align-items: center; gap: 40px; padding: 40px;">';

        // Root node
        if (rootNode) {
            html += this.createTreeNode(rootNode, 'root');
        }

        // Children in a row
        if (childNodes.length > 0) {
            html += '<div style="width: 2px; height: 40px; background: var(--border-light);"></div>';
            html += '<div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">';
            childNodes.slice(0, 20).forEach(node => {
                html += this.createTreeNode(node, 'fork');
            });
            html += '</div>';
        }

        html += '</div>';
        canvas.innerHTML = html;
    },

    /**
     * Create a tree node element
     */
    createTreeNode(node, type) {
        const svgContent = node.monkey_svg
            ? node.monkey_svg
            : '<div style="font-size: 1.5rem;">üêµ</div>';

        return `
            <a href="${node.url}" target="_blank" style="text-decoration: none;">
                <div class="tree-node" style="position: relative;">
                    <div class="tree-node-circle ${type}">
                        ${svgContent}
                    </div>
                    <div class="tree-node-label">${node.owner}</div>
                </div>
            </a>
        `;
    },

    /**
     * Zoom the family tree
     */
    zoomTree(factor) {
        this.treeZoom *= factor;
        this.treeZoom = Math.max(0.5, Math.min(2, this.treeZoom));
        const canvas = document.getElementById('family-tree-canvas');
        canvas.style.transform = `scale(${this.treeZoom})`;
    },

    /**
     * Reset family tree zoom
     */
    resetTree() {
        this.treeZoom = 1;
        const canvas = document.getElementById('family-tree-canvas');
        canvas.style.transform = 'scale(1)';
    },

    /**
     * Copy DNA hash to clipboard
     */
    async copyDNA() {
        const hash = document.getElementById('dna-hash').textContent;
        try {
            await navigator.clipboard.writeText(hash);
            this.showToast('üìã DNA hash copied!', 'success');
        } catch (err) {
            this.showToast('Failed to copy', 'error');
        }
    },

    /**
     * Download monkey SVG
     */
    downloadSVG() {
        const svgElement = document.querySelector('#monkey-frame svg');
        if (!svgElement) {
            this.showToast('No monkey to download!', 'error');
            return;
        }

        const svgData = new XMLSerializer().serializeToString(svgElement);
        const blob = new Blob([svgData], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `forkmonkey-${Date.now()}.svg`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        this.showToast('üì• SVG downloaded!', 'success');
    },

    /**
     * Export DNA as JSON
     */
    exportDNA() {
        const dna = this.data.dna;
        if (!dna) {
            this.showToast('No DNA data available!', 'error');
            return;
        }

        const blob = new Blob([JSON.stringify(dna, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `forkmonkey-dna-${dna.dna_hash || Date.now()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        this.showToast('üß¨ DNA exported!', 'success');
    },

    /**
     * Share monkey (copy URL)
     */
    async shareMonkey() {
        const url = window.location.href;
        this.trackEvent('share_clicked', { method: 'native' });

        if (navigator.share) {
            try {
                await navigator.share({
                    title: 'Check out my ForkMonkey!',
                    text: 'My AI-evolving digital pet on GitHub',
                    url: url
                });
            } catch (err) {
                // User cancelled or share failed
            }
        } else {
            try {
                await navigator.clipboard.writeText(url);
                this.showToast('üîó Link copied!', 'success');
            } catch (err) {
                this.showToast('Failed to copy link', 'error');
            }
        }
    },

    /**
     * Share on Twitter with pre-written viral tweet
     */
    shareTwitter() {
        const stats = this.data.stats || {};
        const rarity = (stats.rarity_score || 0).toFixed(1);
        const generation = stats.generation || 1;
        const ageDays = stats.age_days || 0;
        
        const tweetText = `Check out my ForkMonkey! üêµ

Rarity: ${rarity}/100
Generation: ${generation}
Age: ${ageDays} days

It evolves daily with AI and lives forever on GitHub.

Fork yours free: https://github.com/roeiba/forkMonkey

#ForkMonkey #AI #GitHub #OpenSource`;

        const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;
        window.open(tweetUrl, '_blank', 'width=550,height=420');
        
        this.trackEvent('share_clicked', { platform: 'twitter' });
        this.showToast('üê¶ Opening Twitter...', 'success');
    },

    /**
     * Copy shareable link to clipboard
     */
    async copyShareLink() {
        const url = window.location.href;
        try {
            await navigator.clipboard.writeText(url);
            this.showToast('üìã Link copied! Share it everywhere!', 'success');
            this.trackEvent('share_clicked', { method: 'copy_link' });
        } catch (err) {
            this.showToast('Failed to copy link', 'error');
        }
    },

    /**
     * Share evolution achievement on Twitter
     */
    shareEvolutionTwitter(evolutionData) {
        const text = `Day ${evolutionData.day || '?'} of my #ForkMonkey experiment! üêµ

Today's evolution: ${evolutionData.change || 'Mystery mutation'}
Rarity: ${evolutionData.rarity || '?'}/100

Fork yours free: https://github.com/roeiba/forkMonkey

#AI #GitHub #OpenSource`;

        const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
        window.open(tweetUrl, '_blank', 'width=550,height=420');
        this.trackEvent('share_evolution', { platform: 'twitter' });
    },

    /**
     * Share leaderboard rank
     */
    shareRankTwitter(rank) {
        const stats = this.data.stats || {};
        const text = `üìä My ForkMonkey is ranked #${rank} on the rarity leaderboard!

Rarity: ${(stats.rarity_score || 0).toFixed(1)}/100

Think you can beat me?
https://github.com/roeiba/forkMonkey

#ForkMonkey`;

        const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
        window.open(tweetUrl, '_blank', 'width=550,height=420');
        this.trackEvent('share_rank', { platform: 'twitter', rank });
    },

    /**
     * Open modal with content
     */
    openModal(content) {
        const modal = document.getElementById('detail-modal');
        const body = document.getElementById('modal-body');
        body.innerHTML = content;
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
    },

    /**
     * Close modal
     */
    closeModal() {
        const modal = document.getElementById('detail-modal');
        modal.classList.remove('active');
        document.body.style.overflow = '';
    },

    /**
     * Show toast notification
     */
    showToast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.innerHTML = message;
        container.appendChild(toast);

        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    },

    /**
     * Format trait/property names
     */
    formatName(name) {
        return name
            .split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    },

    /**
     * Initialize particles background
     */
    initParticles() {
        if (typeof particlesJS === 'undefined') return;

        particlesJS('particles-js', {
            particles: {
                number: { value: 50, density: { enable: true, value_area: 1000 } },
                color: { value: '#00ff88' },
                shape: { type: 'circle' },
                opacity: {
                    value: 0.15,
                    random: true,
                    anim: { enable: true, speed: 0.5, opacity_min: 0.05, sync: false }
                },
                size: {
                    value: 2,
                    random: true,
                    anim: { enable: true, speed: 1, size_min: 0.5, sync: false }
                },
                line_linked: {
                    enable: true,
                    distance: 150,
                    color: '#00ff88',
                    opacity: 0.08,
                    width: 1
                },
                move: {
                    enable: true,
                    speed: 0.8,
                    direction: 'none',
                    random: true,
                    straight: false,
                    out_mode: 'out',
                    bounce: false
                }
            },
            interactivity: {
                detect_on: 'canvas',
                events: {
                    onhover: { enable: true, mode: 'grab' },
                    onclick: { enable: true, mode: 'push' },
                    resize: true
                },
                modes: {
                    grab: { distance: 140, line_linked: { opacity: 0.3 } },
                    push: { particles_nb: 3 }
                }
            },
            retina_detect: true
        });
    },

    /**
     * Start auto-refresh for dashboard
     */
    startAutoRefresh() {
        setInterval(() => {
            if (this.currentTab === 'dashboard' && !document.hidden) {
                this.loadAllData().then(() => this.renderDashboard());
            }
        }, this.config.refreshInterval);
    },

    /**
     * Initialize keyboard shortcuts
     */
    initKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Escape to close modal
            if (e.key === 'Escape') {
                this.closeModal();
                this.closeAdoptionWizard();
            }

            // R to refresh
            if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
                this.loadAllData().then(() => {
                    this.switchTab(this.currentTab);
                    this.showToast('üîÑ Refreshed!', 'success');
                });
            }

            // D to download
            if (e.key === 'd' && !e.ctrlKey && !e.metaKey) {
                this.downloadSVG();
            }

            // Number keys for tabs
            const tabMap = { '1': 'dashboard', '2': 'evolution', '3': 'community', '4': 'leaderboard', '5': 'family-tree' };
            if (tabMap[e.key]) {
                this.switchTab(tabMap[e.key]);
            }
        });

        // Close modal on overlay click
        document.getElementById('detail-modal').addEventListener('click', (e) => {
            if (e.target.id === 'detail-modal') {
                this.closeModal();
            }
        });

        console.log('%cKeyboard Shortcuts:', 'color: #ffd93d; font-weight: bold;');
        console.log('%c  1-5 - Switch tabs', 'color: #fff;');
        console.log('%c  R   - Refresh data', 'color: #fff;');
        console.log('%c  D   - Download SVG', 'color: #fff;');
        console.log('%c  Esc - Close modal', 'color: #fff;');
    },

    // ========================================
    // ADOPTION WIZARD METHODS
    // ========================================

    /**
     * Open the adoption wizard modal
     */
    openAdoptionWizard() {
        const modal = document.getElementById('adoption-modal');
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';

        // Reset wizard state
        this.resetAdoptionWizard();

        this.showToast('üêµ Choose your adoption method!', 'info');
    },

    /**
     * Close the adoption wizard modal
     */
    closeAdoptionWizard() {
        const modal = document.getElementById('adoption-modal');
        modal.classList.remove('active');
        document.body.style.overflow = '';
    },

    /**
     * Reset the adoption wizard to initial state
     */
    resetAdoptionWizard() {
        this.adoption = {
            method: null,
            step: 1,
            customization: {}
        };

        // Reset step indicators
        this.updateWizardSteps(1);

        // Show step 1, hide all others
        this.showWizardContent('wizard-step-1');

        // Clear form inputs
        const inputs = document.querySelectorAll('.customization-form input, .customization-form select');
        inputs.forEach(input => {
            if (input.type === 'text') input.value = '';
            if (input.tagName === 'SELECT') input.selectedIndex = 0;
        });
    },

    /**
     * Update wizard step indicators
     */
    updateWizardSteps(currentStep) {
        const steps = document.querySelectorAll('.wizard-step');
        steps.forEach(step => {
            const stepNum = parseInt(step.dataset.step);
            step.classList.remove('active', 'completed');

            if (stepNum === currentStep) {
                step.classList.add('active');
            } else if (stepNum < currentStep) {
                step.classList.add('completed');
            }
        });
    },

    /**
     * Show specific wizard content, hide others
     */
    showWizardContent(contentId) {
        const allContents = document.querySelectorAll('.wizard-content');
        allContents.forEach(content => content.classList.add('hidden'));

        const targetContent = document.getElementById(contentId);
        if (targetContent) {
            targetContent.classList.remove('hidden');
        }
    },

    /**
     * Select adoption method
     */
    selectAdoptionMethod(method) {
        this.adoption.method = method;

        if (method === 'manual') {
            // For manual, skip customization and go straight to GitHub fork
            this.handleManualAdoption();
        } else if (method === 'trustless' || method === 'oauth') {
            // For managed methods, show customization step
            this.adoption.step = 2;
            this.updateWizardSteps(2);
            this.showWizardContent('wizard-step-2');
        }
    },

    /**
     * Handle manual adoption - redirect to GitHub fork
     */
    handleManualAdoption() {
        const forkUrl = `https://github.com/${this.config.repoOwner}/${this.config.repoName}/fork`;

        // Show success-like instructions first
        const content = document.getElementById('wizard-step-3-content');
        content.innerHTML = `
            <div style="text-align: center; padding: 20px;">
                <div style="font-size: 3rem; margin-bottom: 16px;">üîß</div>
                <h3 style="color: var(--primary); font-size: 1.5rem; margin-bottom: 16px;">Manual Setup</h3>
                <p style="color: var(--text-secondary); margin-bottom: 24px;">
                    You'll be redirected to GitHub to fork the repository. After forking:
                </p>
                <ol style="text-align: left; color: var(--text-secondary); margin: 0 auto 24px; max-width: 400px; line-height: 2;">
                    <li>Go to your fork's <strong>Settings ‚Üí Pages</strong></li>
                    <li>Set Source to <strong>GitHub Actions</strong></li>
                    <li>Go to <strong>Actions</strong> tab and enable workflows</li>
                    <li>Run the "Initialize New Monkey" workflow manually</li>
                </ol>
                <a href="${forkUrl}" target="_blank" class="wizard-btn primary" style="text-decoration: none; display: inline-flex;">
                    üç¥ Fork on GitHub
                </a>
                <p style="color: var(--text-dim); font-size: 0.8rem; margin-top: 16px;">
                    Opens in a new tab
                </p>
            </div>
        `;

        this.adoption.step = 3;
        this.updateWizardSteps(3);
        this.showWizardContent('wizard-step-3');
    },

    /**
     * Navigate to next wizard step
     */
    wizardNext() {
        // Collect customization data
        this.adoption.customization = this.getCustomizationData();

        if (this.adoption.method === 'trustless') {
            // Show GitHub username input
            this.showWizardContent('wizard-trustless-input');
            this.adoption.step = 3;
            this.updateWizardSteps(3);
        } else if (this.adoption.method === 'oauth') {
            // Start OAuth flow
            this.initiateOAuthFlow();
        }
    },

    /**
     * Navigate to previous wizard step
     */
    wizardBack() {
        if (this.adoption.step === 2) {
            this.adoption.step = 1;
            this.adoption.method = null;
            this.updateWizardSteps(1);
            this.showWizardContent('wizard-step-1');
        } else if (this.adoption.step === 3) {
            this.adoption.step = 2;
            this.updateWizardSteps(2);
            this.showWizardContent('wizard-step-2');
        }
    },

    /**
     * Get customization data from form
     */
    getCustomizationData() {
        return {
            name: document.getElementById('custom-name')?.value || '',
            body_color: document.getElementById('custom-body-color')?.value || '',
            face_expression: document.getElementById('custom-expression')?.value || '',
            accessory: document.getElementById('custom-accessory')?.value || ''
        };
    },

    /**
     * Submit trustless adoption request
     */
    async submitTrustlessAdoption() {
        const username = document.getElementById('github-username')?.value?.trim();

        if (!username) {
            this.showToast('Please enter your GitHub username', 'error');
            return;
        }

        // Validate username format
        if (!/^[a-zA-Z0-9](?:[a-zA-Z0-9]|-(?=[a-zA-Z0-9])){0,38}$/.test(username)) {
            this.showToast('Invalid GitHub username format', 'error');
            return;
        }

        // Show loading state
        this.showWizardContent('wizard-loading');
        document.getElementById('wizard-loading-text').textContent = 'Creating your monkey...';

        try {
            const response = await fetch(`${this.config.apiBaseUrl}/adopt/trustless`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    github_username: username,
                    customization: this.adoption.customization
                })
            });

            const data = await response.json();

            if (response.ok && data.success) {
                this.showTrustlessSuccess(data);
            } else {
                throw new Error(data.error || 'Failed to create monkey');
            }
        } catch (error) {
            console.error('Trustless adoption error:', error);
            this.showWizardError(error.message || 'Failed to create your monkey. Please try again.');
        }
    },

    /**
     * Show trustless adoption success
     */
    showTrustlessSuccess(data) {
        const content = document.getElementById('wizard-success-content');
        content.innerHTML = `
            <p style="color: var(--text-secondary); margin-bottom: 24px;">
                Your monkey has been created! Check your email for the transfer request.
            </p>
            <div style="background: var(--bg-card); padding: 20px; border-radius: 12px; margin-bottom: 24px;">
                <h4 style="color: var(--primary); margin-bottom: 12px;">üìß Next Steps</h4>
                <ol style="color: var(--text-secondary); text-align: left; line-height: 2; padding-left: 20px;">
                    <li>Check your email from GitHub</li>
                    <li>Accept the repository transfer</li>
                    <li>Your monkey will be live at:
                        <code style="color: var(--accent);">https://${data.github_username || 'you'}.github.io/forkMonkey/</code>
                    </li>
                </ol>
            </div>
            <button class="wizard-btn primary" onclick="ForkMonkey.closeAdoptionWizard()">
                Got it! üéâ
            </button>
        `;
        this.showWizardContent('wizard-success');
        this.showToast('üéâ Monkey created! Check your email.', 'success');
    },

    /**
     * Show wizard error
     */
    showWizardError(message) {
        document.getElementById('wizard-error-message').textContent = message;
        this.showWizardContent('wizard-error');
    },

    /**
     * Initiate OAuth flow for full-trust adoption
     */
    async initiateOAuthFlow() {
        this.showWizardContent('wizard-loading');
        document.getElementById('wizard-loading-text').textContent = 'Redirecting to GitHub...';

        try {
            // Store customization in session storage for after OAuth callback
            sessionStorage.setItem('forkmonkey_customization', JSON.stringify(this.adoption.customization));

            // Redirect to OAuth authorization
            const response = await fetch(`${this.config.apiBaseUrl}/adopt/oauth/authorize`);
            const data = await response.json();

            if (data.auth_url) {
                window.location.href = data.auth_url;
            } else {
                throw new Error('Failed to get authorization URL');
            }
        } catch (error) {
            console.error('OAuth initiation error:', error);
            this.showWizardError('OAuth flow is not yet configured. Please use Manual or Trustless method.');
        }
    },

    /**
     * Complete OAuth adoption (called after OAuth callback)
     */
    async completeOAuthAdoption() {
        const customization = JSON.parse(sessionStorage.getItem('forkmonkey_customization') || '{}');

        this.openAdoptionWizard();
        this.showWizardContent('wizard-loading');
        document.getElementById('wizard-loading-text').textContent = 'Setting up your monkey...';

        try {
            const response = await fetch(`${this.config.apiBaseUrl}/adopt/oauth/complete`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ customization })
            });

            const data = await response.json();

            if (response.ok && data.success) {
                this.showOAuthSuccess(data);
            } else {
                throw new Error(data.error || 'Failed to complete setup');
            }
        } catch (error) {
            console.error('OAuth completion error:', error);
            this.showWizardError(error.message || 'Failed to complete setup. Please try again.');
        } finally {
            sessionStorage.removeItem('forkmonkey_customization');
        }
    },

    /**
     * Show OAuth adoption success
     */
    showOAuthSuccess(data) {
        const content = document.getElementById('wizard-success-content');
        content.innerHTML = `
            <p style="color: var(--text-secondary); margin-bottom: 24px;">
                Your monkey is ready! Everything has been set up automatically.
            </p>
            <div style="background: var(--bg-card); padding: 20px; border-radius: 12px; margin-bottom: 24px;">
                <h4 style="color: var(--primary); margin-bottom: 12px;">üêµ Your Monkey</h4>
                <p style="color: var(--text-secondary); margin-bottom: 12px;">
                    Repository: <a href="${data.repo_url}" target="_blank" style="color: var(--accent);">${data.repo_url}</a>
                </p>
                <p style="color: var(--text-secondary);">
                    Website: <a href="${data.pages_url}" target="_blank" style="color: var(--accent);">${data.pages_url}</a>
                </p>
            </div>
            <a href="${data.pages_url || data.repo_url}" target="_blank" 
               class="wizard-btn primary" style="text-decoration: none; display: inline-flex;">
                üöÄ Visit Your Monkey
            </a>
        `;
        this.showWizardContent('wizard-success');
        this.showToast('üéâ Your monkey is live!', 'success');
    }
};

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', () => ForkMonkey.init());

// Export for global access
window.ForkMonkey = ForkMonkey;
